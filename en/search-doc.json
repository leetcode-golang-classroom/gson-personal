[{"title":"vue-ts 模板","type":0,"sectionRef":"#","url":"/en/blog/vue-ts-template-post","content":"","keywords":"","version":null},{"title":"關於模板​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#關於模板","content":"方便每次開新專案時，不須重裝套件 ","version":null,"tagName":"h2"},{"title":"使用方式​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#使用方式","content":"","version":null,"tagName":"h2"},{"title":"1. 下載模板​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#1-下載模板","content":"","version":null,"tagName":"h3"},{"title":"2. 於 package.json 修改專案名稱​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#2-於-packagejson-修改專案名稱","content":"{ &quot;name&quot;: &quot;vue-ts-template&quot;, &quot;private&quot;: true, &quot;version&quot;: &quot;0.0.0&quot;, &quot;type&quot;: &quot;module&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vue-tsc &amp;&amp; vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot; }, &quot;dependencies&quot;: { &quot;axios&quot;: &quot;^1.1.3&quot;, &quot;jssha&quot;: &quot;^3.3.0&quot;, &quot;pinia&quot;: &quot;^2.0.23&quot;, &quot;tailwindcss&quot;: &quot;^3.2.1&quot;, &quot;vue&quot;: &quot;^3.2.41&quot;, &quot;vue-router&quot;: &quot;^4.1.6&quot; }, &quot;devDependencies&quot;: { &quot;@vitejs/plugin-vue&quot;: &quot;^3.2.0&quot;, &quot;typescript&quot;: &quot;^4.6.4&quot;, &quot;vite&quot;: &quot;^3.2.0&quot;, &quot;vue-tsc&quot;: &quot;^1.0.9&quot; } }  ","version":null,"tagName":"h3"},{"title":"完整版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#完整版","content":"vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0pinia 2.0.23tailwindcss 3.2.1 ","version":null,"tagName":"h2"},{"title":"標準版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#標準版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0pinia 2.0.23 ","version":null,"tagName":"h2"},{"title":"Api版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#api版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6axios 1.1.3jssha 3.3.0 ","version":null,"tagName":"h2"},{"title":"Router版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#router版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4vue-router 4.1.6 ","version":null,"tagName":"h2"},{"title":"簡約版​","type":1,"pageTitle":"vue-ts 模板","url":"/en/blog/vue-ts-template-post#簡約版","content":"連結 vite 3.2.0vue 3.2.41typescript 4.6.4 ","version":null,"tagName":"h2"},{"title":"💡 簡單工廠","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/factory/sfp","content":"","keywords":"","version":"Next"},{"title":"Simple Factory Pattern​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#simple-factory-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#概述","content":"他不屬於 GoF 23 經典設計模式不過他常常被拿來當作學習其他工廠模式的基礎主要概念為: 傳入正確參數，就可以獲得所需要的物件，而且不需知道細節由於建立物件通常由靜態函式實現，因此又稱 靜態工廠方法 ","version":"Next","tagName":"h2"},{"title":"優缺點​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#優缺點","content":"優點: 可以將建立物件，與物件的使用分離開發者不用知道類別的名稱，只需要知道參數的代號即可，可大幅減少使用複查命名的錯誤率如果參數透過檔案傳入，那可以增加系統的靈活性 缺點: 由於它包含了所有類別的建立，因使職責極重，當他無法運作會對系統造成極大的影響如果產品很多，容易造成系統的複雜度提高與程式可讀性降低不易擴展，每當有新的產品加入，就不得不修改工廠邏輯 ","version":"Next","tagName":"h2"},{"title":"應用場景​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#應用場景","content":"需建立的產品比較少，才不會對提高工廠的複雜維度客戶端只需要知道參數即可，對如何建立物件無須知道 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#範例","content":"","version":"Next","tagName":"h2"},{"title":"1. 建立報表介面​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#1-建立報表介面","content":"public interface IChart { void display(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作介面​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#2-實作介面","content":"public class HistogramChart:IChart { public void display() { // 顯示 柱狀圖 } } public class PiChart:IChart { public void display() { // 顯示 圓餅圖 } } public class LineChart:IChart { public void display() { // 顯示 折線圖 } }  ","version":"Next","tagName":"h3"},{"title":"3. 建立列舉​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#3-建立列舉","content":"public enum ChartType { histogram, pie, line }  ","version":"Next","tagName":"h3"},{"title":"4. 工廠類別​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#4-工廠類別","content":"public class Factory { // 靜態工廠方法 public static IChart GetChart(ChartType chartType) { switch (chartType) { case ChartType.histogram : return new HistogramChart(); case ChartType.pie : return new PiChart(); case ChartType.line : return new LineChart(); default: throw new Exception(&quot;無此類型的報表!&quot;); } } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際使用​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#5-實際使用","content":"void Main() { // 柱狀圖 Factory.GetChart(ChartType.histogram).display(); // 圓餅圖 Factory.GetChart(ChartType.pie).display(); // 折線圖 Factory.GetChart(ChartType.line).display(); }  ","version":"Next","tagName":"h3"},{"title":"簡單工廠角色​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#簡單工廠角色","content":"由簡單工廠的結構中，可以歸納出以下幾個角色 ","version":"Next","tagName":"h2"},{"title":"1. 工廠角色 Factory​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#1-工廠角色-factory","content":"他是整個模式的核心，負責實現所有產品應該為靜態方法必須回傳抽象類別 ","version":"Next","tagName":"h3"},{"title":"2. 抽象產品角色 Product​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#2-抽象產品角色-product","content":"為所有商品的父類他必須定義所有商品的規格也會是工廠回傳的對象 ","version":"Next","tagName":"h3"},{"title":"3. 實際產品角色 Concrete​","type":1,"pageTitle":"💡 簡單工廠","url":"/en/docs/designPattern/creationalPattern/factory/sfp#3-實際產品角色-concrete","content":"是工廠角色實現的目標必須繼承並實作抽象產品 由於需要對抽象商品進行重構\\ 因此商品規格不可以包山包海\\ 應該為單一層次的結構 ","version":"Next","tagName":"h3"},{"title":"💡 創造者模式","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/builder","content":"","keywords":"","version":"Next"},{"title":"Builder Pattern​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#builder-pattern","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#概述","content":"它適用於各式物件都需分開建立的複雜情境優點: 容易擴充有一個統一的介面來規範複雜物件的建立分開了物件的建立過程，讓物件建立過程可以建立不同的組合 缺點: 在需求複雜度增加時，需要更多的類別來建立物件，導致開發與維護成本提高 ","version":"Next","tagName":"h2"},{"title":"創造者模式包含​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#創造者模式包含","content":"創造者介面 (Builder interface): 規範建立物件所需要的方法具體創造者 (Concrete Builder): 實作創造者介面的功能指揮者 (Director): 負責處理建立流程產品 (Product): 要被建立的物件 ","version":"Next","tagName":"h3"},{"title":"範例​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#範例","content":"需求: 我需要建立一棟房子，房子要有門、有窗、有牆 ","version":"Next","tagName":"h2"},{"title":"1. 先定義產品 - 房子​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#1-先定義產品---房子","content":" internal class House { /// &lt;summary&gt; /// 門 /// &lt;/summary&gt; public string Door { get; set; } /// &lt;summary&gt; /// 牆 /// &lt;/summary&gt; public string Wall { get; set; } /// &lt;summary&gt; /// 窗戶 /// &lt;/summary&gt; public string Window { get; set; } public override string ToString() { return $&quot;房子包含: {Door}、{Wall}、{Window}&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"2. 定義創造者介面​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#2-定義創造者介面","content":" internal abstract class Builder { public abstract void BuildDoor(); public abstract void BuildWall(); public abstract void BuildWindow(); public abstract House GetProduct(); }  ","version":"Next","tagName":"h3"},{"title":"3. 實作創造者介面 - 具體創造者​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#3-實作創造者介面---具體創造者","content":" internal class ConcreteBuilder : Builder { private House _product = new(); public override void BuildDoor() { _product.Door = &quot;門&quot;; } public override void BuildWall() { _product.Wall = &quot;牆壁&quot;; } public override void BuildWindow() { _product.Window = &quot;窗戶&quot;; } public override House GetProduct() { return _product; } }  ","version":"Next","tagName":"h3"},{"title":"4. 建立指揮者​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#4-建立指揮者","content":" internal class Director { public static void Construct(Builder builder) { builder.BuildDoor(); builder.BuildWall(); builder.BuildWindow(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 客戶端使用​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#5-客戶端使用","content":"Builder builder = new ConcreteBuilder(); Director.Construct(builder); var house = builder.GetProduct(); Console.WriteLine(house.ToString());  ","version":"Next","tagName":"h3"},{"title":"6.結果​","type":1,"pageTitle":"💡 創造者模式","url":"/en/docs/designPattern/creationalPattern/builder#6結果","content":"輸出: 房子包含: 門、牆壁、窗戶  ","version":"Next","tagName":"h3"},{"title":"💡 抽象工廠","type":0,"sectionRef":"#","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory","content":"","keywords":"","version":"Next"},{"title":"Abstract Factory​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#abstract-factory","content":"","version":"Next","tagName":"h2"},{"title":"概述​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#概述","content":"他用於創建物件的類別提供一個 interface ，並且建立相關的物件在使用時不用去指定他具體的類別 ","version":"Next","tagName":"h2"},{"title":"範例​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#範例","content":"首先我們有一個需求，會有一個車廠來生產各式車輛 ","version":"Next","tagName":"h2"},{"title":"1. 先建立一個汽車的 interface​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#1-先建立一個汽車的-interface","content":" internal interface ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;車種&lt;/returns&gt; string GetCarType(); }  ","version":"Next","tagName":"h3"},{"title":"2. 實作 跑車 與 家庭車 類別​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#2-實作-跑車-與-家庭車-類別","content":" /// &lt;summary&gt; /// 跑車 /// &lt;/summary&gt; internal class SportsCar : ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;跑車&lt;/returns&gt; public string GetCarType() { return &quot;Sports Car&quot;; } } /// &lt;summary&gt; /// 家庭式 /// &lt;/summary&gt; internal class FamilyCar : ICar { /// &lt;summary&gt; /// 取得車種 /// &lt;/summary&gt; /// &lt;returns&gt;家庭車&lt;/returns&gt; public string GetCarType() { return &quot;Family Car&quot;; } }  ","version":"Next","tagName":"h3"},{"title":"3. 建立抽象工廠 interface​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#3-建立抽象工廠-interface","content":" internal interface ICarFactory { /// &lt;summary&gt; /// 創建車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; ICar CreateCar(); }  ","version":"Next","tagName":"h3"},{"title":"4. 實作 跑車工廠 與 家庭車工廠​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#4-實作-跑車工廠-與-家庭車工廠","content":" /// &lt;summary&gt; /// 跑車工廠 /// &lt;/summary&gt; internal class SportsCarFactory : ICarFactory { /// &lt;summary&gt; /// 取得車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public ICar CreateCar() { return new SportsCar(); } } /// &lt;summary&gt; /// 家庭車工廠 /// &lt;/summary&gt; internal class FamilyCarFactory : ICarFactory { /// &lt;summary&gt; /// 取得車輛實體 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public ICar CreateCar() { return new FamilyCar(); } }  ","version":"Next","tagName":"h3"},{"title":"5. 實際生產​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#5-實際生產","content":" ICarFactory factory; Console.WriteLine(&quot;請輸入要生產的車種代號:&quot;); Console.WriteLine(@&quot;1. 跑車 2. 家庭車&quot;); string carNo = Console.ReadLine(); switch (carNo) { case &quot;1&quot;: factory = new SportsCarFactory(); break; case &quot;2&quot;: factory = new FamilyCarFactory(); break; default: throw new Exception(&quot;無此車種&quot;); } ICar car = factory.CreateCar(); Console.WriteLine($&quot;生產 {car.GetCarType()} X 1&quot;);  ","version":"Next","tagName":"h3"},{"title":"6. 結果​","type":1,"pageTitle":"💡 抽象工廠","url":"/en/docs/designPattern/creationalPattern/factory/abstractFactory#6-結果","content":"輸入 1輸出 請輸入要生產的車種代號: 1. 跑車 2. 家庭車 1 生產 Sports Car X 1  輸入 2輸出 請輸入要生產的車種代號: 1. 跑車 2. 家庭車 2 生產 Family Car X 1  ","version":"Next","tagName":"h3"},{"title":"💡 設計模式概述(一)","type":0,"sectionRef":"#","url":"/en/docs/designPattern/overview1","content":"","keywords":"","version":"Next"},{"title":"設計模式的起源​","type":1,"pageTitle":"💡 設計模式概述(一)","url":"/en/docs/designPattern/overview1#設計模式的起源","content":"設計模式的誕生 : 出自於 Christopher Alexander&lt;哈佛大學建築學博士&gt;，號稱 The father of patternsChristopher Alexander 與其團隊用了將近 20 年的時間，調查住宅周邊環境他們發現人們對舒適的住宅與城市環境之間存在著一些共同的認同定律Christopher Alexander 在著作 A Pattern Language: Towns, Buildings, Construction 中把這些認同規律歸納為 253 个模式每個模式都是從 Context(前提條件)Theme 或 Problem（目標問題）Solution（解決方案） 後來 Christopher Alexander 給出了一個建議: A pattern is a successful or efficient solution to a recurring problem within a context 模式是在特定環境下人們解決某類重複出現問題的一套成功獲有效的解決方案  ","version":"Next","tagName":"h2"},{"title":"設計模式思想的引用​","type":1,"pageTitle":"💡 設計模式概述(一)","url":"/en/docs/designPattern/overview1#設計模式思想的引用","content":"1990 年，軟體工程界開始關注 Christopher Alexander 在住宅領域的突破在 1991~1992 年間由四位軟體工程的學者，將其引入程式開發中在 1994 年歸納並發表出 23 種常用的設計模式主要用模式來統一溝通物件導向在 1. 溝通 2. 設計 3.開發之間的代溝 軟體模式(Software Patterns)就此誕生，軟體開發的生命週期上都存在著一些被認同的模式 軟體模式示圖: ","version":"Next","tagName":"h2"},{"title":"📪 馬戲團","type":0,"sectionRef":"#","url":"/en/docs/csDelegate/csDelegate1","content":"","keywords":"","version":"Next"},{"title":"1. 定義要使用的委派​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#1-定義要使用的委派","content":"使用delegate關鍵字定義傳入參數string name  /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private delegate void Animal(string name);  ","version":"Next","tagName":"h2"},{"title":"2. 定義要接收委派的函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#2-定義要接收委派的函式","content":"定義馬戲團表演的函式傳入委派與動物姓名在函式裡實現委派animal(name);  /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;動物名字&lt;/param&gt; private static void RunCircus(Animal animal, string name) { animal(name); }  ","version":"Next","tagName":"h2"},{"title":"3. 定義小狗函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#3-定義小狗函式","content":" /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private static void Dog(string name) { Console.WriteLine($&quot;汪汪! 我是{name}&quot;); }  ","version":"Next","tagName":"h2"},{"title":"4. 在主程式實例化動物委派​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#4-在主程式實例化動物委派","content":"將小狗作為函式帶入  Animal deleDog = new Animal(Dog);  ","version":"Next","tagName":"h2"},{"title":"5. 將呼叫馬戲團函式​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#5-將呼叫馬戲團函式","content":"將動物委派傳入  RunCircus(deleDog, &quot;小狗&quot;);   ","version":"Next","tagName":"h2"},{"title":"完整程式碼​","type":1,"pageTitle":"📪 馬戲團","url":"/en/docs/csDelegate/csDelegate1#完整程式碼","content":"using System; using System.Collections.Generic; using System.Text; namespace CSharpExercise.EventDemo { public class DelegateExercise1 { /// &lt;summary&gt; /// 主程式 /// &lt;/summary&gt; public void Main() { Animal deleDog = new Animal(Dog); RunCircus(deleDog, &quot;小狗&quot;); } /// &lt;summary&gt; /// 定義委派 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private delegate void Animal(string name); /// &lt;summary&gt; /// 定義函式 /// &lt;/summary&gt; /// &lt;param name=&quot;animal&quot;&gt;動物的委派&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;動物名字&lt;/param&gt; private static void RunCircus(Animal animal, string name) { animal(name); } /// &lt;summary&gt; /// 小狗函式 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;姓名&lt;/param&gt; private static void Dog(string name) { Console.WriteLine($&quot;汪汪! 我是{name}&quot;); } } }  ","version":"Next","tagName":"h2"},{"title":"Gson Liang","type":0,"sectionRef":"#","url":"/en/docs/intro","content":"","keywords":"","version":"Next"},{"title":"聯絡資訊​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#聯絡資訊","content":"電子信箱: yuanyu90221@gmail.com ","version":"Next","tagName":"h2"},{"title":"工作經歷​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#工作經歷","content":"2022.11-now: TKspring 後端工程師2019.11-2021.10: 成境科技 後端工程師2017.10-2019.10： Coolbitx 全端工程師2016.04-2017.10： Gorilla Tech 網頁開發工程師2015.04-2016.04: SYSCOM 軟體開發工程師2014.04-2015.04: ASUS 軔體開發工程師 ","version":"Next","tagName":"h2"},{"title":"學歷​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#學歷","content":"2010.09-2012.09 國立交通大學 資工所 論文影像與倒影之對稱偵測2006.09-2012.06 國立中興大學 應用數學系 ","version":"Next","tagName":"h2"},{"title":"擁有技能​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#擁有技能","content":"自動化測試環境 Github Action Gitlab Pipeline Gitea Drone雲端環境與容器技術 AWS Heroku Docker後端程式語言 nodejs java前端程式框架 vue bulma資料庫 Postgresql Mongo DynamoDB快取 Redis ","version":"Next","tagName":"h2"},{"title":"簡歷​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#簡歷","content":"","version":"Next","tagName":"h2"},{"title":"自我介紹​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#自我介紹","content":"你好，我叫梁元宇。參與過的工作是主要負責後端開發與雲端環境部署。 我是一個喜歡用技術解決問題的人 以下說明我用技術解決過的問題： 在原本的程式碼功能未驗證的部份加入了自動化測試，提升開發的程式碼品質與提高有效驗證開發功能 在過去待過的公司中根據不同的版控系統設置了不同的自動化測試環境 舉例來說: Gitlab 中使用 Pipeline(gitlab-ci), Github 用 Github Action 在Coolbitx 時， 我在 Gitlab Pipeline 加入測試驗證了，每個區塊鏈交易時間格式顯示正確。 在RedPill 時， 我在 Github Action 加入驗證測試了，確認Promo Code 發行正確不重複。 讓手動部署變成自動部署，讓部署環境能夠透過程式碼有效管控(infra as code) 在 RedPill， 使用了 aws cdk 來做環境部署 在 Coolbitx， 使用了 beanstalk 來做環境部署 讓服務能夠再部署後有效通知給開發團隊 在 RedPill， 透過 AWS CloudWatch 設置Metric 把蒐集到的有問題的狀態推波到 slack，讓開發團隊能夠有效率去檢查問題。 在 Coolbitx， 透過 AWS CloudWatch 設置Metric 把蒐集到的有問題的狀態推波到 slack，讓 App 團隊能夠有效率去檢查問題 透過 git submodule 切分出公用函式庫，讓各團隊開發不會相互影響 在 Coolbitx 時，因為 ReactNative 架構的關係，兩個平台(Android, IOS)會在開發新的功能時相互影響。所以我把 Coolbitx Wallet 這個 ReactNatvie app 對區塊鏈處理的部份，獨立出一個 core library 分出一個 submodule， 讓 Android 與 IOS 開發團隊可以根據自己開發周期取用對應的 core library 透過 Docker 降低開發環境建制難度 在 Coolbitx 時，開發 Sygna Bridge 這個稽核功能有用到 AWS SQS 以及 AWS DynamoDB。為了方便開發，我在本機環境寫了 Docker file 建制了一個測試模擬環境，方便開發人員快速開發及驗證 ","version":"Next","tagName":"h3"},{"title":"IT 鐵人賽紀錄​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#it-鐵人賽紀錄","content":"從以太坊白皮書理解 web 3 概透過以太坊白皮書理解區塊鏈技術圖解 blind 75: 以圖解方式練習解題 （2022.9)透過練習 blind 75 ，來整理過去學過的演算法與資料結構k8s 入門學習 30天(2021.10)撰寫 30 篇文章分享，由 k8s 官網所學到的基礎知識golang leetcode 30天挑戰(2020.8)紀錄30天用 golang 練習 leetcode 的解題思考過程Vue.js Web Component 基礎以及 Vuex狀態管理(2019.8)撰寫了 8 篇文章來分享關於 Vue.js 以及 Vuex 的基礎知識 ","version":"Next","tagName":"h3"},{"title":"個人特質​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#個人特質","content":"我本身是一個喜歡團隊合作的人。在過去幾間公司裡，常常透過與團隊討論研究來解決問題，而在問題解決後也喜歡分享解決問題的過程 從自我介紹與鐵人賽也可以知道我是喜歡研究新技術的人。對於能解決問題的新技術，我向來是熱於追求 喜歡用有效的方式做事情，對於無意義的加班很排斥！ ","version":"Next","tagName":"h3"},{"title":"總結​","type":1,"pageTitle":"Gson Liang","url":"/en/docs/intro#總結","content":"最近的兩份工作裡用到的技術棧主要是以 nodejs 為主，本身不排斥學習新的語言，但需要給予合理的學習時間還有幫助。 感謝您撥空閱讀本人履歷，希望有進一步面談的機會。除了讓我了解貴單位的詳細需求，貴單位也可以更加了解我的能力和人格特質，謝謝。 ","version":"Next","tagName":"h3"}]